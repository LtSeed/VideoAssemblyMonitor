package nusri.fyp.demo.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import nusri.fyp.demo.converter.ActionObservationConverter;
import nusri.fyp.demo.state_machine.*;

import java.time.LocalDateTime;
import java.util.*;

/**
 * 
 * StateMachineLog entity class that records the execution flow of the state machine.<br>
 * This includes the user identifier, associated preset, start and end times, 
 * and observation data stored by timestamp (action recognition information).
 * 
 */
@Setter
@Getter
@Entity
@Table(name = "state_machine_log")
public class StateMachineLog {

    /**
     * 
     * Auto-incrementing primary key to uniquely identify the log record.<br>
     * This field is automatically generated by the database.
     * 
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * 
     * The user identifier associated with this state machine log entry.<br>
     * This is a required field.
     * 
     */
    @Column(nullable = false)
    private String user;

    /**
     * 
     * The preset associated with this log entry.<br>
     * It is a Many-to-One relationship with the Preset entity, meaning many logs can refer to one preset.<br>
     * This field is a foreign key that points to the preset used during the execution of the state machine.
     * 
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "preset_id", nullable = false)
    private Preset preset;

    /**
     * 
     * The start time of the state machine execution.<br>
     * This is a required field and represents the timestamp when the state machine started.
     * 
     */
    @Column(nullable = false)
    private LocalDateTime startTime;

    /**
     * 
     * The end time of the state machine execution.<br>
     * This is a required field and represents the timestamp when the state machine finished.
     * 
     */
    @Column(nullable = false)
    private LocalDateTime endTime;

    /**
     * 
     * A map of timestamps to action observations.<br>
     * This map contains all the action observations that occurred at specific timestamps.<br>
     * The key is the timestamp (in milliseconds), and the value is a list of action observations for that timestamp.<br>
     * The observations are serialized and deserialized using {@link ActionObservationConverter}.
     * 
     */
    @Convert(converter = ActionObservationConverter.class)
    private Map<Long, List<AbstractActionObservation>> observations;

    /**
     * 
     * No-argument constructor for the StateMachineLog entity.<br>
     * This constructor is used by JPA for entity creation and initialization.
     * 
     */
    public StateMachineLog() {
    }

    /**
     * 
     * Retrieves the matching {@link PresetNode} objects based on the observations.<br>
     * The method returns a map of timestamps to the corresponding {@link PresetNode} objects.<br>
     * A matching logic is applied where the {@link AbstractActionObservation#s()} method's result is checked against 
     * the actions in the {@link PresetNode} list.<br>
     * The match is considered if the action from the observation matches the action in the node either as a prefix or suffix, or exactly.
     * 
     *
     * @return A map of timestamps and corresponding matching {@link PresetNode} objects.
     * @see PresetNode
     */
    public Map<Long, List<PresetNode>> getMatchingPresetNodes() {
        return getMatchingPresetNodes(false);
    }

    /**
     * 
     * Retrieves the matching {@link PresetNode} objects based on the observations.<br>
     * The method returns a map of timestamps to the corresponding {@link PresetNode} objects.<br>
     * The match logic follows the same as {@link #getMatchingPresetNodes()}, but with an option to add a "transfer" action if no observations exist.<br>
     * A matching logic is applied where the {@link AbstractActionObservation#s()} method's result is checked against 
     * the actions in the {@link PresetNode} list.<br>
     * The match is considered if the action from the observation matches the action in the node either as a prefix or suffix, or exactly.
     * 
     *
     * @param addTransfer If true, adds a "transfer" action observation if no observations are present.
     * @return A map of timestamps and corresponding matching {@link PresetNode} objects.
     * @see PresetNode
     */
    public Map<Long, List<PresetNode>> getMatchingPresetNodes(boolean addTransfer) {

        Map<Long, List<PresetNode>> result = new TreeMap<>();

        // Iterate through the observations and match them to preset nodes
        for (Map.Entry<Long, List<AbstractActionObservation>> entry : observations.entrySet()) {
            Long timestamp = entry.getKey();
            List<AbstractActionObservation> observationsList = new ArrayList<>(entry.getValue());

            if (observationsList.isEmpty() && addTransfer) {
                ActionObservation actionObservation = new ActionObservation();
                actionObservation.setProbability(1);
                actionObservation.setActionAndObject("transfer");

                observationsList.add(actionObservation);
            }

            List<PresetNode> matchingNodes = new ArrayList<>();

            for (AbstractActionObservation observation : observationsList) {
                String observationAction = observation.s();

                // Matching logic for each PresetNode
                for (PresetNode presetNode : preset.getNodes()) {
                    for (String action : presetNode.getActions()) {
                        if (action.startsWith(observationAction) || action.endsWith(observationAction)) {
                            if (!matchingNodes.contains(presetNode)) {
                                matchingNodes.add(presetNode);
                            }
                        }
                        if (action.equals(observationAction)) {
                            if (!matchingNodes.contains(presetNode)) {
                                matchingNodes.add(presetNode);
                                matchingNodes.add(presetNode);
                            }
                        }
                    }
                }
            }

            if (!matchingNodes.isEmpty()) {
                result.put(timestamp, matchingNodes);
            }
        }

        return result;
    }

    /**
     * 
     * Retrieves the matching {@link PresetNode} IDs for each timestamp.<br>
     * This method calls {@link #getMatchingPresetNodes(boolean)} and extracts the IDs of the matching {@link PresetNode}s.
     * 
     *
     * @param addTransfer If true, adds a "transfer" action observation if no observations are present.
     * @return A map of timestamps and corresponding matching {@link PresetNode} IDs.
     */
    public Map<Long, List<Integer>> getMatchingPresetNodesIds(boolean addTransfer) {

        Map<Long, List<PresetNode>> matchingPresetNodes = getMatchingPresetNodes(addTransfer);
        Map<Long, List<Integer>> result = new TreeMap<>();

        matchingPresetNodes.forEach((timestamp, nodes) -> {
            result.put(timestamp, nodes.stream().map(node -> node.getId().getNumber()).toList());
        });

        return result;
    }

    /**
     * Generates all possible chains of {@link PresetNode}s.<br>
     * This method calculates every possible permutation of the provided {@link PresetNode} list.<br>
     * The permutations represent all possible step sequences for the state machine based on the given preset.
     *
     * @param presetNodes A list of all {@link PresetNode}s.
     * @return A list of all possible chains (permutations) of {@link PresetNode}s.
     */
    public List<List<PresetNode>> generateAllNodeChains(List<PresetNode> presetNodes) {
        List<List<PresetNode>> allChains = new ArrayList<>();
        permute(presetNodes, 0, allChains);
        return allChains;
    }

    /**
     * 
     * Recursive helper method for generating all permutations of {@link PresetNode}s.<br>
     * This method uses backtracking to find all possible permutations of the input list.
     * 
     *
     * @param presetNodes The list of {@link PresetNode}s to permute.
     * @param start       The starting index for the current permutation.
     * @param allChains   The list that will hold all the generated chains.
     */
    private void permute(List<PresetNode> presetNodes, int start, List<List<PresetNode>> allChains) {
        if (start == presetNodes.size()) {
            allChains.add(new ArrayList<>(presetNodes));
            return;
        }

        for (int i = start; i < presetNodes.size(); i++) {
            Collections.swap(presetNodes, start, i);
            permute(presetNodes, start + 1, allChains);
            Collections.swap(presetNodes, start, i);  // backtrack
        }
    }

    /**
     * 
     * Returns the duration of the entire process from the first observation to the last.<br>
     * This is the difference between the maximum and minimum timestamps in the observations.
     * 
     *
     * @return The duration of the process in milliseconds. If no data exists, returns 0.
     */
    public long getDuration() {
        return observations.keySet().stream().mapToLong(k -> k).max().orElse(0) - observations.keySet().stream().mapToLong(k -> k).min().orElse(0);
    }
}
