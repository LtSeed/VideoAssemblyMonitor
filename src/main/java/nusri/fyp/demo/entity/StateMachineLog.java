package nusri.fyp.demo.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import nusri.fyp.demo.converter.ActionObservationConverter;
import nusri.fyp.demo.service.ConfigService;
import nusri.fyp.demo.state_machine.*;
import org.slf4j.Logger;

import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.*;

/**
 * 
 * StateMachineLog entity class that records the execution flow of the state machine.<br>
 * This includes the user identifier, associated preset, start and end times, 
 * and observation data stored by timestamp (action recognition information).
 * 
 */
@Setter
@Getter
@Entity
@Table(name = "state_machine_log")
public class StateMachineLog {

    /**
     * 
     * Auto-incrementing primary key to uniquely identify the log record.<br>
     * This field is automatically generated by the database.
     * 
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * 
     * The user identifier associated with this state machine log entry.<br>
     * This is a required field.
     * 
     */
    @Column(nullable = false)
    private String user;

    /**
     * 
     * The preset associated with this log entry.<br>
     * It is a Many-to-One relationship with the Preset entity, meaning many logs can refer to one preset.<br>
     * This field is a foreign key that points to the preset used during the execution of the state machine.
     * 
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "preset_id", nullable = false)
    private Preset preset;

    /**
     * 
     * The start time of the state machine execution.<br>
     * This is a required field and represents the timestamp when the state machine started.
     * 
     */
    @Column(nullable = false)
    private LocalDateTime startTime;

    /**
     * 
     * The end time of the state machine execution.<br>
     * This is a required field and represents the timestamp when the state machine finished.
     * 
     */
    @Column(nullable = false)
    private LocalDateTime endTime;

    /**
     * 
     * A map of timestamps to action observations.<br>
     * This map contains all the action observations that occurred at specific timestamps.<br>
     * The key is the timestamp (in milliseconds), and the value is a list of action observations for that timestamp.<br>
     * The observations are serialized and deserialized using {@link ActionObservationConverter}.
     * 
     */
    @Convert(converter = ActionObservationConverter.class)
    private Map<Long, List<AbstractActionObservation>> observations;

    /**
     * 
     * No-argument constructor for the StateMachineLog entity.<br>
     * This constructor is used by JPA for entity creation and initialization.
     * 
     */
    public StateMachineLog() {
    }

    /**
     * 
     * Retrieves the matching {@link PresetNode} objects based on the observations.<br>
     * The method returns a map of timestamps to the corresponding {@link PresetNode} objects.<br>
     * A matching logic is applied where the {@link AbstractActionObservation#s()} method's result is checked against 
     * the actions in the {@link PresetNode} list.<br>
     * The match is considered if the action from the observation matches the action in the node either as a prefix or suffix, or exactly.
     * 
     *
     * @return A map of timestamps and corresponding matching {@link PresetNode} objects.
     * @see PresetNode
     */
    public Map<Long, List<PresetNode>> getMatchingPresetNodes() {
        return getMatchingPresetNodes(false);
    }

    /**
     * 
     * Retrieves the matching {@link PresetNode} objects based on the observations.<br>
     * The method returns a map of timestamps to the corresponding {@link PresetNode} objects.<br>
     * The match logic follows the same as {@link #getMatchingPresetNodes()}, but with an option to add a "transfer" action if no observations exist.<br>
     * A matching logic is applied where the {@link AbstractActionObservation#s()} method's result is checked against 
     * the actions in the {@link PresetNode} list.<br>
     * The match is considered if the action from the observation matches the action in the node either as a prefix or suffix, or exactly.
     * 
     *
     * @param addTransfer If true, adds a "transfer" action observation if no observations are present.
     * @return A map of timestamps and corresponding matching {@link PresetNode} objects.
     * @see PresetNode
     */
    public Map<Long, List<PresetNode>> getMatchingPresetNodes(boolean addTransfer) {

        Map<Long, List<PresetNode>> result = new TreeMap<>();

        // Iterate through the observations and match them to preset nodes
        for (Map.Entry<Long, List<AbstractActionObservation>> entry : observations.entrySet()) {
            Long timestamp = entry.getKey();
            List<AbstractActionObservation> observationsList = new ArrayList<>(entry.getValue());

            if (observationsList.isEmpty() && addTransfer) {
                ActionObservation actionObservation = new ActionObservation();
                actionObservation.setProbability(1);
                actionObservation.setActionAndObject("transfer");

                observationsList.add(actionObservation);
            }

            List<PresetNode> matchingNodes = new ArrayList<>();

            for (AbstractActionObservation observation : observationsList) {
                String observationAction = observation.s();

                // Matching logic for each PresetNode
                for (PresetNode presetNode : preset.getNodes()) {
                    for (String action : presetNode.getActions()) {
                        if (action.startsWith(observationAction) || action.endsWith(observationAction)) {
                            if (!matchingNodes.contains(presetNode)) {
                                matchingNodes.add(presetNode);
                            }
                        }
                        if (action.equals(observationAction)) {
                            if (!matchingNodes.contains(presetNode)) {
                                matchingNodes.add(presetNode);
                                matchingNodes.add(presetNode);
                            }
                        }
                    }
                }
            }

            if (!matchingNodes.isEmpty()) {
                result.put(timestamp, matchingNodes);
            }
        }

        return result;
    }

    /**
     * 
     * Retrieves the matching {@link PresetNode} IDs for each timestamp.<br>
     * This method calls {@link #getMatchingPresetNodes(boolean)} and extracts the IDs of the matching {@link PresetNode}s.
     * 
     *
     * @param addTransfer If true, adds a "transfer" action observation if no observations are present.
     * @return A map of timestamps and corresponding matching {@link PresetNode} IDs.
     */
    public Map<Long, List<Integer>> getMatchingPresetNodesIds(boolean addTransfer) {

        Map<Long, List<PresetNode>> matchingPresetNodes = getMatchingPresetNodes(addTransfer);
        Map<Long, List<Integer>> result = new TreeMap<>();

        matchingPresetNodes.forEach((timestamp, nodes) -> {
            result.put(timestamp, nodes.stream().map(node -> node.getId().getNumber()).toList());
        });

        return result;
    }

    /**
     * Generates all possible chains of {@link PresetNode}s.<br>
     * This method calculates every possible permutation of the provided {@link PresetNode} list.<br>
     * The permutations represent all possible step sequences for the state machine based on the given preset.
     *
     * @param presetNodes A list of all {@link PresetNode}s.
     * @return A list of all possible chains (permutations) of {@link PresetNode}s.
     */
    public List<List<PresetNode>> generateAllNodeChains(List<PresetNode> presetNodes) {
        List<List<PresetNode>> allChains = new ArrayList<>();
        permute(presetNodes, 0, allChains);
        return allChains;
    }

    /**
     * 
     * Recursive helper method for generating all permutations of {@link PresetNode}s.<br>
     * This method uses backtracking to find all possible permutations of the input list.
     * 
     *
     * @param presetNodes The list of {@link PresetNode}s to permute.
     * @param start       The starting index for the current permutation.
     * @param allChains   The list that will hold all the generated chains.
     */
    private void permute(List<PresetNode> presetNodes, int start, List<List<PresetNode>> allChains) {
        if (start == presetNodes.size()) {
            allChains.add(new ArrayList<>(presetNodes));
            return;
        }

        for (int i = start; i < presetNodes.size(); i++) {
            Collections.swap(presetNodes, start, i);
            permute(presetNodes, start + 1, allChains);
            Collections.swap(presetNodes, start, i);  // backtrack
        }
    }

    /**
     * 
     * Simulates the execution of the state machine based on the observations in the current log entry.<br>
     * If Quota is enabled, it performs real-time updates; if Quota is disabled, it performs {@link SegmentPartitionByDP} inference.<br>
     * The final sequence of steps (nodes) is returned as a timeline.
     * 
     *
     * @param configService The service that provides configuration information for the state machine.
     * @param log           The logger used for logging.
     * @return A sorted map of timestamps to the most probable {@link PresetNode} at that time.
     * @see StateMachine
     * @see SegmentPartitionByDP
     */
    public TreeMap<Long, PresetNode> getTimelineOfProc(ConfigService configService, Logger log) {
        log.debug("getMatchingPresetNodes: {}", getMatchingPresetNodes());

        // Initialize state machine
        StateMachine fsm = new StateMachine(this.preset);
        TreeMap<Long, List<AbstractActionObservation>> obsList = new TreeMap<>(observations);
        fsm.setObservations(obsList);

        // Check if Quota is enabled
        String quotaMode = configService.getQuotaConfig(this.preset.getName()).getQuotaMode();
        boolean isQuotaDisabled = "disabled".equalsIgnoreCase(quotaMode);

        TreeMap<Long, PresetNode> timeline = new TreeMap<>();

        if (!isQuotaDisabled) {
            // If Quota is enabled, update the state step by step
            for (Map.Entry<Long, List<AbstractActionObservation>> e : obsList.entrySet()) {
                Long timestampMs = e.getKey();
                double timestampSec = timestampMs.doubleValue();

                // Call the update method for each observation
                fsm.updateStateProbability(e.getValue(), timestampSec, configService);

                // Get the most probable state (PresetNode)
                PresetNode mostProbable = fsm.getMostProbableState();
                timeline.put(e.getKey(), mostProbable);
            }

        } else {
            log.debug("Quota disabled -> Using offline HMM/Viterbi inference.");
            Map<Long, List<Integer>> matchingPresetNodesIds = getMatchingPresetNodesIds(false);
            List<Long> optimalPartitions = SegmentPartitionByDP.findOptimalPartitions(matchingPresetNodesIds);

            TreeMap<Long, PresetNode> result = new TreeMap<>();

            assert optimalPartitions.size() == preset.getNodes().size();
            PresetNode node = null;
            try {
                node = preset.getNode(1);
            } catch (Throwable e) {
                log.error(e.getMessage());
            }
            if (node != null)
                result.put(this.getStartTime().toInstant(ZoneOffset.of("+8")).toEpochMilli(), node);

            for (int i = 1; i < optimalPartitions.size(); i++) {
                Long timestampMs = optimalPartitions.get(i);
                try {
                    node = preset.getNode(i + 1);
                    if (node != null)
                        result.put(timestampMs + this.getStartTime().toInstant(ZoneOffset.of("+8")).toEpochMilli(), node);
                } catch (Throwable e) {
                    log.error(e.getMessage());
                }
            }
            log.debug("Timeline result: {}", result);
            return result;
        }
        log.debug("Timeline result before filter: {}", timeline);

        // Filter out repeated states, only keeping the state change moments
        Map.Entry<Long, PresetNode> first = timeline.entrySet().stream()
                .filter(e -> e.getValue().getId().getNumber() >= 0)
                .min(Comparator.comparingDouble(e -> e.getValue().getId().getNumber()))
                .orElse(null);

        if (first == null) {
            return null;
        }

        Map.Entry<Long, PresetNode> longPresetNodeEntry = timeline.firstEntry();
        timeline.put(longPresetNodeEntry.getKey(), first.getValue());

        TreeMap<Long, PresetNode> filtered = new TreeMap<>();
        for (Map.Entry<Long, PresetNode> entry : timeline.entrySet()) {
            Long currentTime = entry.getKey();
            Long prevKey = timeline.lowerKey(currentTime);
            if (prevKey == null) {
                filtered.put(currentTime, entry.getValue());
                continue;
            }
            if (entry.getValue().getId().getNumber() == timeline.get(prevKey).getId().getNumber()) {
                continue;
            }
            filtered.put(currentTime, entry.getValue());
        }

        return filtered;
    }

    /**
     * 
     * Returns the duration of the entire process from the first observation to the last.<br>
     * This is the difference between the maximum and minimum timestamps in the observations.
     * 
     *
     * @return The duration of the process in milliseconds. If no data exists, returns 0.
     */
    public long getDuration() {
        return observations.keySet().stream().mapToLong(k -> k).max().orElse(0) - observations.keySet().stream().mapToLong(k -> k).min().orElse(0);
    }
}
